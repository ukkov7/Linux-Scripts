< #define ISVISIBLEONTAG(C, T)    ((C->tags & T))
< #define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
---
> #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
75a75
>       const int ch;
93c93
<       int basew, baseh, incw, inch, maxw, maxh, minw, minh;
---
>       int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
96c96
<       int isfixed, iscentered, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
---
>       int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
104d103
<       int type;
116,123d114
< typedef struct {
<       int mw, mh;    /* >= matching */
<       int layout;    /* only apply if this is the current layout, <0 for no matching */
<       int nmaster;   /* the new nmaster to apply */
<       float mfact;   /* the new mfact to apply */
< } LayoutMonitorRule;
<
< typedef struct Pertag Pertag;
143d133
<       Pertag *pertag;
151d140
<       int iscentered;
155a145,152
>
> static void musicchannel(const Arg *arg);
> static void realshit(const Arg* arg);
> static void prerun();
> static void sendKeyEvent();
> /* static void defining(); */
> /* static void runProgram(); */
>
157d153
< static void applylmrules(void);
163d158
< static void attachtop(Client *c);
165d159
< static void bstack(Monitor *m);
171d164
< static void col(Monitor *);
184d176
< static Client *findbefore(Client *c);
190d181
< static Client *getclientundermouse(void);
196,197c187
< static void gaplessgrid(Monitor *);
< static void incnmaster(const Arg *arg);
---
> /* static void incnmaster(const Arg *arg); */
200d189
< static void killunsel(const Arg *arg);
207d195
< static void movestack(const Arg *arg);
209,210c197
< static void pop(Client *);
< static Client *prevtiled(Client *c);
---
> static void pop(Client *c);
214d200
< static void resetlayout(const Arg *arg);
222c208
< static void sendmon(Client *c, Monitor *m, int keeptags);
---
> static void sendmon(Client *c, Monitor *m);
235,236c221
< static void tagallmon(const Arg *arg);
< static void tile(Monitor *);
---
> static void tile(Monitor *m);
255c240
< static void warp(Client *c);
---
> static void warp(const Client *c);
264d248
< static Client *prevzoom = NULL;
269c253
< static int bh, blw = 0;      /* bar geometry */
---
> static int bh;               /* bar height */
283d266
<       [KeyRelease] = keypress,
302,310d284
< struct Pertag {
<       unsigned int curtag, prevtag; /* current and previous tag */
<       int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
<       float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
<       unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
<       const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
<       int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
< };
<
316,348d289
< applylmrules(void)
< {
<       size_t t;
<
<       for (t = 0; t <= LENGTH(tags); t++) {
<               float new_mfact = mfact;
<               int new_nmaster = nmaster;
<               size_t i;
<
<               for (i = 0; i < LENGTH(lm_rules); i++) {
<                       const LayoutMonitorRule *lmr = &lm_rules[i];
<
<                       if (selmon->mw >= lmr->mw &&
<                           selmon->mh >= lmr->mh &&
<                           selmon->lt[selmon->pertag->sellts[t]] == &layouts[lmr->layout])
<                       {
<                               new_mfact = lmr->mfact;
<                               new_nmaster = lmr->nmaster;
<                               break;
<                       }
<               }
<
<               selmon->pertag->mfacts[t] = new_mfact;
<               selmon->pertag->nmasters[t] = new_nmaster;
<
<       }
<
<       selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
<       selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
<       arrange(selmon);
< }
<
< void
370d310
<                       c->iscentered = r->iscentered;
417a358,359
>               if (!c->hintsvalid)
>                       updatesizehints(c);
481,499d422
< attachtop(Client *c)
< {
<       int n;
<       Monitor *m = selmon;
<       Client *below;
<
<       for (n = 1, below = c->mon->clients;
<               below && below->next && (below->isfloating || !ISVISIBLEONTAG(below, c->tags) || n != m->nmaster);
<               n = below->isfloating || !ISVISIBLEONTAG(below, c->tags) ? n + 0 : n + 1, below = below->next);
<       c->next = NULL;
<       if (below) {
<               c->next = below->next;
<               below->next = c;
<       }
<       else
<               c->mon->clients = c;
< }
<
< void
506,537d428
< static void
< bstack(Monitor *m) {
<       int w, h, mh, mx, tx, ty, tw;
<       unsigned int i, n;
<       Client *c;
<
<       for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
<       if (n == 0)
<               return;
<       if (n > m->nmaster) {
<               mh = m->nmaster ? m->mfact * m->wh : 0;
<               tw = m->ww / (n - m->nmaster);
<               ty = m->wy + mh;
<       } else {
<               mh = m->wh;
<               tw = m->ww;
<               ty = m->wy;
<       }
<       for (i = mx = 0, tx = m->wx, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
<               if (i < m->nmaster) {
<                       w = (m->ww - mx) / (MIN(n, m->nmaster) - i);
<                       resize(c, m->wx + mx, m->wy, w - (2 * c->bw), mh - (2 * c->bw), 0);
<                       mx += WIDTH(c);
<               } else {
<                       h = m->wh - mh;
<                       resize(c, tx, ty, tw - (2 * c->bw), h - (2 * c->bw), 0);
<                       if (tw != m->ww)
<                               tx += WIDTH(c);
<               }
<       }
< }
<
562c453
<               } else if (ev->x < x + blw)
---
>               } else if (ev->x < x + TEXTW(selmon->ltsymbol))
610a502
>       free(scheme);
654,679d545
< col(Monitor *m) {
<       unsigned int i, n, h, w, x, y,mw;
<       Client *c;
<
<       for(n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
<       if(n == 0)
<               return;
<         if(n > m->nmaster)
<                 mw = m->nmaster ? m->ww * m->mfact : 0;
<         else
<                 mw = m->ww;
<       for(i = x = y = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
<               if(i < m->nmaster) {
<                        w = (mw - x) / (MIN(n, m->nmaster)-i);
<                          resize(c, x + m->wx, m->wy, w - (2*c->bw), m->wh - (2*c->bw), False);
<                       x += WIDTH(c);
<               }
<               else {
<                       h = (m->wh - y) / (n - i);
<                       resize(c, x + m->wx, m->wy + y, m->ww - x  - (2*c->bw), h - (2*c->bw), False);
<                       y += HEIGHT(c);
<               }
<       }
< }
<
< void
722d587
<                       applylmrules();
783d647
<       unsigned int i;
794,807d657
<       m->pertag = ecalloc(1, sizeof(Pertag));
<       m->pertag->curtag = m->pertag->prevtag = 1;
<
<       for (i = 0; i <= LENGTH(tags); i++) {
<               m->pertag->nmasters[i] = m->nmaster;
<               m->pertag->mfacts[i] = m->mfact;
<
<               m->pertag->ltidxs[i][0] = m->lt[0];
<               m->pertag->ltidxs[i][1] = m->lt[1];
<               m->pertag->sellts[i] = m->sellt;
<
<               m->pertag->showbars[i] = m->showbar;
<       }
<
894c744
<       w = blw = TEXTW(m->ltsymbol);
---
>       w = TEXTW(m->ltsymbol);
950,959d799
< Client *
< findbefore(Client *c)
< {
<       Client *tmp;
<       if (c == selmon->clients)
<               return NULL;
<       for (tmp = selmon->clients; tmp && tmp->next != c; tmp = tmp->next);
<       return tmp;
< }
<
1006a847
>       warp(selmon->sel);
1032d872
<               warp(c);
1052,1065d891
< Client *
< getclientundermouse(void)
< {
<       int ret, di;
<       unsigned int dui;
<       Window child, dummy;
<
<       ret = XQueryPointer(dpy, root, &dummy, &child, &di, &di, &di, &di, &dui);
<       if (!ret)
<               return NULL;
<
<       return wintoclient(child);
< }
<
1106c932
<       if (name.encoding == XA_STRING)
---
>       if (name.encoding == XA_STRING) {
1108,1112c934,936
<       else {
<               if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
<                       strncpy(text, *list, size - 1);
<                       XFreeStringList(list);
<               }
---
>       } else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
>               strncpy(text, *list, size - 1);
>               XFreeStringList(list);
1158,1199c982,987
< void
< gaplessgrid(Monitor *m) {
<       unsigned int n, cols, rows, cn, rn, i, cx, cy, cw, ch;
<       Client *c;
<
<       for(n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) ;
<       if(n == 0)
<               return;
<
<       /* grid dimensions */
<       for(cols = 0; cols <= n/2; cols++)
<               if(cols*cols >= n)
<                       break;
<       if(n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
<               cols = 2;
<       rows = n/cols;
<
<       /* window geometries */
<       cw = cols ? m->ww / cols : m->ww;
<       cn = 0; /* current column number */
<       rn = 0; /* current row number */
<       for(i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
<               if(i/rows + 1 > cols - n%cols)
<                       rows = n/cols + 1;
<               ch = rows ? m->wh / rows : m->wh;
<               cx = m->wx + cn*cw;
<               cy = m->wy + rn*ch;
<               resize(c, cx, cy, cw - 2 * c->bw, ch - 2 * c->bw, False);
<               rn++;
<               if(rn >= rows) {
<                       rn = 0;
<                       cn++;
<               }
<       }
< }
<
< void
< incnmaster(const Arg *arg)
< {
<       selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
<       arrange(selmon);
< }
---
> /* void */
> /* incnmaster(const Arg *arg) */
> /* { */
> /*    selmon->nmaster = MAX(selmon->nmaster + arg->i, 0); */
> /*    arrange(selmon); */
> /* } */
1224d1011
<               && ev->type == keys[i].type
1247,1269d1033
< killunsel(const Arg *arg)
< {
<       Client *i = NULL;
<
<       if (!selmon->sel)
<               return;
<
<       for (i = selmon->clients; i; i = i->next) {
<               if (ISVISIBLE(i) && i != selmon->sel) {
<                       if (!sendevent(i, wmatom[WMDelete])) {
<                               XGrabServer(dpy);
<                               XSetErrorHandler(xerrordummy);
<                               XSetCloseDownMode(dpy, DestroyAll);
<                               XKillClient(dpy, i->win);
<                               XSync(dpy, False);
<                               XSetErrorHandler(xerror);
<                               XUngrabServer(dpy);
<                       }
<               }
<       }
< }
<
< void
1294,1301c1058,1063
<       if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
<               c->x = c->mon->mx + c->mon->mw - WIDTH(c);
<       if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
<               c->y = c->mon->my + c->mon->mh - HEIGHT(c);
<       c->x = MAX(c->x, c->mon->mx);
<       /* only fix client y-offset, if the client center might cover the bar */
<       c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
<               && (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
---
>       if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
>               c->x = c->mon->wx + c->mon->ww - WIDTH(c);
>       if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
>               c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
>       c->x = MAX(c->x, c->mon->wx);
>       c->y = MAX(c->y, c->mon->wy);
1304,1308d1065
<       if(c->iscentered) {
<               c->x = (c->mon->mw - WIDTH(c)) / 2;
<               c->y = (c->mon->mh - HEIGHT(c)) / 2;
<       }
<
1322c1079
<       attachtop(c);
---
>       attach(c);
1334d1090
<       warp(c);
1353,1355c1109
<       if (!XGetWindowAttributes(dpy, ev->window, &wa))
<               return;
<       if (wa.override_redirect)
---
>       if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
1447c1201
<               sendmon(c, m, 0);
---
>               sendmon(c, m);
1453,1503d1206
< void
< movestack(const Arg *arg) {
<       Client *c = NULL, *p = NULL, *pc = NULL, *i;
<
<       if(arg->i > 0) {
<               /* find the client after selmon->sel */
<               for(c = selmon->sel->next; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
<               if(!c)
<                       for(c = selmon->clients; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
<
<       }
<       else {
<               /* find the client before selmon->sel */
<               for(i = selmon->clients; i != selmon->sel; i = i->next)
<                       if(ISVISIBLE(i) && !i->isfloating)
<                               c = i;
<               if(!c)
<                       for(; i; i = i->next)
<                               if(ISVISIBLE(i) && !i->isfloating)
<                                       c = i;
<       }
<       /* find the client before selmon->sel and c */
<       for(i = selmon->clients; i && (!p || !pc); i = i->next) {
<               if(i->next == selmon->sel)
<                       p = i;
<               if(i->next == c)
<                       pc = i;
<       }
<
<       /* swap c and selmon->sel selmon->clients in the selmon->clients list */
<       if(c && c != selmon->sel) {
<               Client *temp = selmon->sel->next==c?selmon->sel:selmon->sel->next;
<               selmon->sel->next = c->next==selmon->sel?c:c->next;
<               c->next = temp;
<
<               if(p && p != c)
<                       p->next = c;
<               if(pc && pc != selmon->sel)
<                       pc->next = selmon->sel;
<
<               if(selmon->sel == selmon->clients)
<                       selmon->clients = c;
<               else if(c == selmon->clients)
<                       selmon->clients = selmon->sel;
<
<               arrange(selmon);
<       }
<
<       warp(selmon->sel);
< }
<
1520,1529d1222
< Client *
< prevtiled(Client *c) {
<       Client *p, *r;
<
<       for(p = selmon->clients, r = NULL; p && p != c; p = p->next)
<               if(!p->isfloating && ISVISIBLE(p))
<                       r = p;
<       return r;
< }
<
1550c1243
<                       updatesizehints(c);
---
>                       c->hintsvalid = 0;
1588,1596d1280
< resetlayout(const Arg *arg)
< {
<       Arg default_layout = {.v = &layouts[0]};
<
<       setlayout(&default_layout);
<       applylmrules();
< }
<
< void
1613,1616d1296
<
<       if ((nexttiled(c->mon->clients) == c) && !(nexttiled(c->next)))
<               resetlayout(NULL);
<
1673c1353
<               sendmon(c, m, 0);
---
>               sendmon(c, m);
1701a1382,1383
>       if (m == selmon && (m->tagset[m->seltags] & m->sel->tags) && selmon->lt[selmon->sellt] != &layouts[2])
>               warp(m->sel);
1740,1744d1421
<
<       /* We may have last run manage() on a window that isn't visible. To be
<        * deterministic on startup, place focus/warp on current master if any
<        * client exists. */
<       warp(nexttiled(selmon->clients));
1748c1425
< sendmon(Client *c, Monitor *m, int keeptags)
---
> sendmon(Client *c, Monitor *m)
1756,1758c1433,1434
<       if (!keeptags)
<               c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
<       attachtop(c);
---
>       c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
>       attach(c);
1842c1518
<               selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
---
>               selmon->sellt ^= 1;
1844c1520
<               selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (const Layout *)arg->v;
---
>               selmon->lt[selmon->sellt] = (Layout *)arg->v;
1846,1847c1522,1524
<       applylmrules();
<       if (!selmon->sel)
---
>       if (selmon->sel)
>               arrange(selmon);
>       else
1862c1539
<       selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
---
>       selmon->mfact = f;
1934d1610
<       applylmrules();
1937d1612
<
1980,1981d1654
<       if (arg->v == dmenucmd)
<               dmenumon[0] = '0' + selmon->num;
1983d1655
<               char *const *cmd = arg->v;
1987,1989c1659,1660
<               execvp(cmd[0], cmd);
<               perror(" failed");
<               exit(EXIT_SUCCESS);
---
>               execvp(((char **)arg->v)[0], (char **)arg->v);
>               die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
1998c1669,1670
<               view(arg);
---
>               focus(NULL);
>               arrange(selmon);
2007,2020c1679
<       sendmon(selmon->sel, dirtomon(arg->i), 0);
<       focusmon(arg);
< }
<
< void
< tagallmon(const Arg *arg)
< {
<       Client *c;
<
<       if (!mons->next)
<               return;
<       for (c = selmon->clients; c; c = c->next)
<               sendmon(c, dirtomon(arg->i), 1);
<       focusmon(arg);
---
>       sendmon(selmon->sel, dirtomon(arg->i));
2054c1713
<       selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
---
>       selmon->showbar = !selmon->showbar;
2086d1744
<               warp(NULL);
2094d1751
<       int i;
2098,2120d1754
<
<               if (newtagset == ~0) {
<                       selmon->pertag->prevtag = selmon->pertag->curtag;
<                       selmon->pertag->curtag = 0;
<               }
<
<               /* test if the user did not select the same tag */
<               if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
<                       selmon->pertag->prevtag = selmon->pertag->curtag;
<                       for (i = 0; !(newtagset & 1 << i); i++) ;
<                       selmon->pertag->curtag = i + 1;
<               }
<
<               /* apply settings for this view */
<               selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
<               selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
<               selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
<               selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
<               selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
<
<               if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
<                       togglebar(NULL);
<
2150a1785
>               XSelectInput(dpy, c->win, NoEventMask);
2158a1794
>       focus(NULL);
2161d1796
<       focus(getclientundermouse());
2248,2254c1883,1903
<               if (n <= nn) { /* new monitors available */
<                       for (i = 0; i < (nn - n); i++) {
<                               for (m = mons; m && m->next; m = m->next);
<                               if (m)
<                                       m->next = createmon();
<                               else
<                                       mons = createmon();
---
>
>               /* new monitors if nn > n */
>               for (i = n; i < nn; i++) {
>                       for (m = mons; m && m->next; m = m->next);
>                       if (m)
>                               m->next = createmon();
>                       else
>                               mons = createmon();
>               }
>               for (i = 0, m = mons; i < nn && m; m = m->next, i++)
>                       if (i >= n
>                       || unique[i].x_org != m->mx || unique[i].y_org != m->my
>                       || unique[i].width != m->mw || unique[i].height != m->mh)
>                       {
>                               dirty = 1;
>                               m->num = i;
>                               m->mx = m->wx = unique[i].x_org;
>                               m->my = m->wy = unique[i].y_org;
>                               m->mw = m->ww = unique[i].width;
>                               m->mh = m->wh = unique[i].height;
>                               updatebarpos(m);
2256,2282c1905,1914
<                       for (i = 0, m = mons; i < nn && m; m = m->next, i++)
<                               if (i >= n
<                               || unique[i].x_org != m->mx || unique[i].y_org != m->my
<                               || unique[i].width != m->mw || unique[i].height != m->mh)
<                               {
<                                       dirty = 1;
<                                       m->num = i;
<                                       m->mx = m->wx = unique[i].x_org;
<                                       m->my = m->wy = unique[i].y_org;
<                                       m->mw = m->ww = unique[i].width;
<                                       m->mh = m->wh = unique[i].height;
<                                       updatebarpos(m);
<                               }
<               } else { /* less monitors available nn < n */
<                       for (i = nn; i < n; i++) {
<                               for (m = mons; m && m->next; m = m->next);
<                               while ((c = m->clients)) {
<                                       dirty = 1;
<                                       m->clients = c->next;
<                                       detachstack(c);
<                                       c->mon = mons;
<                                       attachtop(c);
<                                       attachstack(c);
<                               }
<                               if (m == selmon)
<                                       selmon = mons;
<                               cleanupmon(m);
---
>               /* removed monitors if n > nn */
>               for (i = nn; i < n; i++) {
>                       for (m = mons; m && m->next; m = m->next);
>                       while ((c = m->clients)) {
>                               dirty = 1;
>                               m->clients = c->next;
>                               detachstack(c);
>                               c->mon = mons;
>                               attach(c);
>                               attachstack(c);
2283a1916,1918
>                       if (m == selmon)
>                               selmon = mons;
>                       cleanupmon(m);
2361a1997
>       c->hintsvalid = 1;
2415,2417d2050
<       int i;
<       unsigned int tmptag;
<
2421c2054
<       if (arg->ui & TAGMASK) {
---
>       if (arg->ui & TAGMASK)
2423,2445d2055
<               selmon->pertag->prevtag = selmon->pertag->curtag;
<
<               if (arg->ui == ~0)
<                       selmon->pertag->curtag = 0;
<               else {
<                       for (i = 0; !(arg->ui & 1 << i); i++) ;
<                       selmon->pertag->curtag = i + 1;
<               }
<       } else {
<               tmptag = selmon->pertag->prevtag;
<               selmon->pertag->prevtag = selmon->pertag->curtag;
<               selmon->pertag->curtag = tmptag;
<       }
<
<       selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
<       selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
<       selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
<       selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
<       selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
<
<       if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
<               togglebar(NULL);
<
2448,2456d2057
<       warp(NULL);
< }
<
< void
< warp(Client *c)
< {
<       /* Try to warp to the active window. */
<       if (!c)
<               c = selmon->sel;
2458,2461c2059,2068
<       /* If there's no active window, just warp to the middle of the screen. */
<       if (!c) {
<               XWarpPointer(dpy, None, root, 0, 0, 0, 0, selmon->wx + selmon->ww/2, selmon->wy + selmon->wh/2);
<               return;
---
>       if (((arg->ui & TAGMASK) == ((1 << 9) & TAGMASK)))
>       {
>               sendKeyEvent(XK_a);
>               sendKeyEvent(XK_o);
>       }
>       else if (((arg->ui & TAGMASK) == ((1 << 7) & TAGMASK)))
>       {
>               Arg a;
>               a.v = (const char*[]){"/bin/sh", "-c", "chromium $(xclip -o -selection clipboard)", NULL};
>               spawn(&a);
2462a2070,2072
>       else if (((arg->ui & TAGMASK) == ((1 << 6) & TAGMASK)))
>       {
>               Arg a;
2464c2074,2079
<       XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w / 2, c->h / 2);
---
>               a.v = (const char*[]){"/bin/sh", "-c", "xsetwacom set \"HUION H420 stylus\" PressureCurve 0 100 0 0", NULL};
>               spawn(&a);
>
>               a.v = (const char*[]){"/bin/sh", "-c", "xsetwacom set \"HUION H420 stylus\" MapToOutput DVI-D-0", NULL};
>               spawn(&a);
>       }
2537d2151
<       Client *at = NULL, *cold, *cprevious = NULL;
2539,2540c2153,2166
<       if (!selmon->lt[selmon->sellt]->arrange
<       || (selmon->sel && selmon->sel->isfloating))
---
>       if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
>               return;
>       if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
>               return;
>       pop(c);
> }
>
> void
> warp(const Client *c)
> {
>       int x, y;
>
>       if (!c) {
>               XWarpPointer(dpy, None, root, 0, 0, 0, 0, selmon->wx + selmon->ww/2, selmon->wy + selmon->wh/2);
2542,2551d2167
<       if (c == nexttiled(selmon->clients)) {
<               at = findbefore(prevzoom);
<               if (at)
<                       cprevious = nexttiled(at->next);
<               if (!cprevious || cprevious != prevzoom) {
<                       prevzoom = NULL;
<                       if (!c || !(c = nexttiled(c->next)))
<                               return;
<               } else
<                       c = cprevious;
2553,2565c2169,2263
<       cold = nexttiled(selmon->clients);
<       if (c != cold && !at)
<               at = findbefore(c);
<       detach(c);
<       attach(c);
<       /* swap windows instead of pushing the previous one down */
<       if (c != cold && at) {
<               prevzoom = cold;
<               if (cold && at != cold) {
<                       detach(cold);
<                       cold->next = at->next;
<                       at->next = cold;
<               }
---
>
>       if (!getrootptr(&x, &y) ||
>           (x > c->x - c->bw &&
>            y > c->y - c->bw &&
>            x < c->x + c->w + c->bw*2 &&
>            y < c->y + c->h + c->bw*2) ||
>           (y > c->mon->by && y < c->mon->by + bh) ||
>           (c->mon->topbar && !y))
>               return;
>
>       XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w / 2, c->h / 2);
> }
>
> void
> sendKeyEvent(KeySym s)
> {
>       XKeyEvent event;
>
>       event.time = CurrentTime;
>     event.display = dpy;
>       event.window = selmon->sel->win;
>       event.root = root;
>       event.subwindow = None;
>       event.x = 1;
>       event.y = 1;
>       event.x_root = 1;
>       event.y_root = 1;
>       event.same_screen = True;
>       event.keycode = XKeysymToKeycode(dpy, s);
>       event.state = 0;
>       event.type = KeyPress;
>
>     XSendEvent(dpy, event.window, True, KeyPressMask, (XEvent *)&event);
> }
>
> void
> defining()
> {
>       sendKeyEvent(XK_a);
>       sendKeyEvent(XK_o);
> }
>
> void
> musicchannel(const Arg *arg)
> {
>       Arg a;
>
>       // focus 2nd monitor
>       a.i = -1;
>       focusmon(&a);
>
>     // Find the window which has the current keyboard focus
>     //XGetInputFocus(dpy, &winFocus, &revert);
>
>     // Register an interest to the x11 application to receive events
>     // This client wants to receive key-press and key-release events associated with winFocus
>     //XSelectInput(dpy, winFocus, KeyPressMask|KeyReleaseMask);
>
>     // Send a fake key press event to the window
>       sendKeyEvent(XK_m);
>
>       // Switch to new tag
>       a.ui = 1 << (arg->ch - 1);
>       view(&a);
>
>     // Find the window which has the current keyboard focus
>     //XGetInputFocus(dpy, &winFocus, &revert);
>
>     // Register an interest to the x11 application to receive events
>     // This client wants to receive key-press and key-release events associated with winFocus
>     //XSelectInput(dpy, winFocus, KeyPressMask|KeyReleaseMask);
>
>     // Send a fake key press event to the window
>       sendKeyEvent(XK_m);
>
>       // Switch back to 1st monitor
>       a.i = -1;
>       focusmon(&a);
> }
>
> void
> realshit(const Arg* arg)
> {
>       Arg a;
>       Monitor *m;
>       m = dirtomon(-1);
>       // if on either monitor im not on tag 9 do:
>       if ((((1 << 8) & TAGMASK) != selmon->tagset[selmon->seltags]) || (((1 << 8) & TAGMASK) != m->tagset[m->seltags]))
>       {
>               a.ui = 1 << 8;
>               view(&a);
>               a.i = -1;
>               focusmon(&a);
>               a.ui = 1 << 8;
>               view(&a);
2567,2569c2265,2266
<       arrange(c->mon);
<       if (cprevious)
<               warp(cold);
---
>
>       // else restore to prev (do something bout that second statement!)
2571c2268,2275
<               warp(c);
---
>       {
>               a.ui = 0;
>               view(&a);
>               a.i = -1;
>               focusmon(&a);
>               a.ui = 0;
>               view(&a);
>       }
2573a2278,2314
> /* void */
> /* runProgram() */
> /* { */
> /*    Arg a; */
> /*    a.v = (const char*[]){"/bin/sh", "-c", "qutebrowser ':set-cmd-text -s :spawn --userscript find_definition.sh'", NULL}; */
> /*    spawn(&a); */
> /* } */
>
> void
> prerun()
> {
>       Arg a;
>
>       a.v = (const char*[]){"/bin/sh", "-c", "scripts/autostart.sh", NULL};
>       spawn(&a);
>
>       FILE *f = fopen(".value", "r");
>       int c = fgetc(f);
>
>       a.ui = 1 << (c - 49);
>       view(&a);
>       a.i = -1;
>       focusmon(&a);
>       fclose(f);
> }
>
>       /* tricks */
>
>       /* define SPAWN(cmd) a.v = (const char*[]){"/bin/sh", "-c", cmd, NULL} */
>
>       /* FILE *f = fopen("filename", "a"); */
>       /* char str[21]; */
>       /* sprintf(str, "%lu", selmon->sel->win); */
>       /* fprintf(f, "Starting!\n"); */
>       /* fprintf(f, "%s", str); */
>       /* fclose(f); */
>
2591a2333
>       prerun();
2597,2598d2338
<
< /* vim: set noexpandtab: */
